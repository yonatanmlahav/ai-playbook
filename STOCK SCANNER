# Stock Breakout Scanner - משולב עם הפרויקט הקיים שלך

## מבנה הפרויקט המעודכן

```
your-project/
├── main.py          (הקיים שלך - נשדרג)
├── train.py         (הקיים שלך - נשאיר)
├── requirements.txt (נוסיף ספריות)
├── main/            (התיקיות הקיימות)
├── stock_scanner/   (חדש!)
│   ├── __init__.py
│   ├── api.py           # FastAPI server
│   ├── scanner.py       # Stock scanning
│   ├── features.py      # Feature engineering
│   └── integration.py   # Integration with your train.py
├── frontend/        (React UI)
│   ├── package.json
│   ├── vite.config.js
│   └── src/
│       ├── App.jsx
│       └── components/
└── railway.json
```

---

## שלב 1: עדכן `requirements.txt`

הוסף את השורות האלה לקובץ הקיים:

```txt
# Your existing packages stay...

# Add these for the scanner:
fastapi==0.109.0
uvicorn[standard]==0.27.0
yfinance==0.2.35
ta==0.11.0
aiohttp==3.9.1
python-multipart==0.0.6
```

---

## שלב 2: `stock_scanner/__init__.py`

```python
# stock_scanner/__init__.py
from .api import app
from .scanner import StockScanner
from .features import FeatureEngine
from .integration import IntegratedModel

__all__ = ['app', 'StockScanner', 'FeatureEngine', 'IntegratedModel']
```

---

## שלב 3: `stock_scanner/integration.py`

**משלב את המודל שלך עם הסורק!**

```python
# stock_scanner/integration.py
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from train import engineer_features
from joblib import load
import pandas as pd
import numpy as np

class IntegratedModel:
    """
    משתמש במודלים שאתה מאמן ב-train.py
    """
    def __init__(self):
        self.model = None
        self.scaler = None
        self.load_models()
    
    def load_models(self):
        """טוען את המודלים שנשמרו"""
        try:
            # נסה לטעון את המודל הטוב ביותר
            if os.path.exists('model.joblib'):
                self.model = load('model.joblib')
                print("✅ Loaded main model")
            elif os.path.exists('model_ensemble.joblib'):
                self.model = load('model_ensemble.joblib')
                print("✅ Loaded ensemble model")
            else:
                print("⚠️ No trained model found. Please run train.py first.")
                return False
            
            # טען scaler
            if os.path.exists('scaler.joblib'):
                self.scaler = load('scaler.joblib')
                print("✅ Loaded scaler")
            
            return True
        except Exception as e:
            print(f"❌ Error loading models: {e}")
            return False
    
    def is_loaded(self):
        return self.model is not None
    
    def prepare_features(self, stock_data):
        """
        ממיר נתוני מניה לפורמט שהמודל שלך מצפה לו
        """
        # המר את נתוני yfinance לפורמט שלך
        df = pd.DataFrame(stock_data)
        
        # חשב אינדיקטורים טכניים
        features_dict = self._calculate_technical_indicators(df)
        
        # השתמש באותה פונקציית feature engineering מ-train.py
        features_df = pd.DataFrame([features_dict])
        engineered = engineer_features(features_df)
        
        return engineered
    
    def _calculate_technical_indicators(self, df):
        """מחשב RSI, MACD, וכו' מנתוני מניה"""
        import ta
        
        df['close'] = pd.to_numeric(df['close'])
        df['high'] = pd.to_numeric(df['high'])
        df['low'] = pd.to_numeric(df['low'])
        df['volume'] = pd.to_numeric(df['volume'])
        
        # RSI
        rsi = ta.momentum.RSIIndicator(df['close'], window=14).rsi().iloc[-1]
        
        # MACD
        macd = ta.trend.MACD(df['close'])
        macd_value = macd.macd_diff().iloc[-1]
        
        # Volume Spike
        avg_volume = df['volume'].rolling(20).mean().iloc[-1]
        current_volume = df['volume'].iloc[-1]
        vol_spike = current_volume / avg_volume if avg_volume > 0 else 1
        
        # Breakout %
        high_20 = df['high'].rolling(20).max().iloc[-1]
        current_price = df['close'].iloc[-1]
        breakout_pct = ((current_price - high_20) / high_20 * 100) if high_20 > 0 else 0
        
        # Gap %
        if len(df) > 1:
            gap_pct = ((df['open'].iloc[-1] - df['close'].iloc[-2]) / df['close'].iloc[-2] * 100)
        else:
            gap_pct = 0
        
        # A_Score (ציון משוקלל)
        score = (
            (rsi / 100 * 30) +
            (min(vol_spike / 3, 1) * 30) +
            (1 if macd_value > 0 else 0) * 20 +
            (1 if breakout_pct > 0 else 0) * 20
        )
        
        return {
            'RSI': rsi,
            'MACD': macd_value,
            'VolSpike': vol_spike,
            'Breakout%': breakout_pct,
            'Gap%': gap_pct,
            'A_Score': score
        }
    
    def predict(self, stock_data):
        """
        חיזוי אם תהיה פריצה
        מחזיר: (probability, prediction_label)
        """
        if not self.is_loaded():
            raise ValueError("Model not loaded. Run train.py first.")
        
        # הכן features
        X = self.prepare_features(stock_data)
        
        # Scale אם יש scaler
        if self.scaler:
            X_scaled = self.scaler.transform(X)
        else:
            X_scaled = X
        
        # חזה
        if hasattr(self.model, 'predict_proba'):
            proba = self.model.predict_proba(X_scaled)[0]
            return float(proba[1]), 'Win' if proba[1] > 0.5 else 'Loss'
        else:
            pred = self.model.predict(X_scaled)[0]
            return float(pred), 'Win' if pred == 1 else 'Loss'
```

---

## שלב 4: `stock_scanner/scanner.py`

```python
# stock_scanner/scanner.py
import yfinance as yf
from datetime import datetime, timedelta
from typing import List, Dict
from .integration import IntegratedModel

class StockScanner:
    def __init__(self):
        self.model = IntegratedModel()
    
    async def fetch_stock_data(self, symbol: str) -> List[Dict]:
        """מושך נתוני מניה מ-yfinance"""
        try:
            stock = yf.Ticker(symbol)
            
            end_date = datetime.now()
            start_date = end_date - timedelta(days=150)
            
            df = stock.history(start=start_date, end=end_date)
            
            if df.empty:
                raise ValueError(f"No data for {symbol}")
            
            data = []
            for date, row in df.iterrows():
                data.append({
                    "date": date.strftime("%Y-%m-%d"),
                    "open": float(row["Open"]),
                    "high": float(row["High"]),
                    "low": float(row["Low"]),
                    "close": float(row["Close"]),
                    "volume": int(row["Volume"])
                })
            
            return data[-100:]
        
        except Exception as e:
            print(f"Error fetching {symbol}: {e}")
            raise e
    
    async def scan_single(self, symbol: str, threshold: float = 0.5) -> Dict:
        """סורק מניה בודדת"""
        data = await self.fetch_stock_data(symbol)
        
        if len(data) < 50:
            return None
        
        # חזה באמצעות המודל שלך
        probability, label = self.model.predict(data)
        
        if probability >= threshold:
            return {
                "symbol": symbol,
                "prediction": probability,
                "label": label,
                "confidence": probability * 100,
                "last_price": data[-1]["close"],
                "change_pct": ((data[-1]["close"] - data[-2]["close"]) / data[-2]["close"] * 100),
                "volume": data[-1]["volume"],
                "date": data[-1]["date"]
            }
        
        return None
    
    async def scan_multiple(self, symbols: List[str], threshold: float = 0.5) -> List[Dict]:
        """סורק מספר מניות"""
        results = []
        
        for symbol in symbols:
            try:
                result = await self.scan_single(symbol, threshold)
                if result:
                    results.append(result)
            except Exception as e:
                print(f"Error scanning {symbol}: {e}")
                continue
        
        return sorted(results, key=lambda x: x["prediction"], reverse=True)
```

---

## שלב 5: `stock_scanner/api.py`

```python
# stock_scanner/api.py
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
import uvicorn
import os
from .scanner import StockScanner

app = FastAPI(title="Stock Breakout Scanner API")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

scanner = StockScanner()

class ScanRequest(BaseModel):
    symbols: List[str]
    threshold: Optional[float] = 0.5

@app.get("/")
async def root():
    return {
        "message": "Stock Breakout Scanner API",
        "version": "1.0.0",
        "model_loaded": scanner.model.is_loaded()
    }

@app.get("/health")
async def health():
    return {"status": "healthy", "model_loaded": scanner.model.is_loaded()}

@app.get("/api/stocks/{symbol}")
async def get_stock(symbol: str):
    try:
        data = await scanner.fetch_stock_data(symbol.upper())
        result = await scanner.scan_single(symbol.upper())
        return {
            "symbol": symbol.upper(),
            "data": data,
            "prediction": result
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/scanner/scan")
async def scan_stocks(request: ScanRequest):
    try:
        results = await scanner.scan_multiple(request.symbols, request.threshold)
        return results
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/scanner/watchlist")
async def scan_watchlist():
    """סורק watchlist ידוע"""
    default_symbols = [
        "AAPL", "MSFT", "GOOGL", "AMZN", "TSLA", "NVDA", "META", "AMD",
        "NFLX", "DIS", "PYPL", "SQ", "SHOP", "ROKU", "ZM", "DOCU"
    ]
    
    try:
        results = await scanner.scan_multiple(default_symbols, threshold=0.6)
        return results
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    port = int(os.getenv("PORT", 8000))
    uvicorn.run(app, host="0.0.0.0", port=port)
```

---

## שלב 6: עדכן `main.py` (אופציונלי)

```python
# main.py - הוסף בסוף הקובץ הקיים שלך:

# ... הקוד הקיים שלך ...

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1 and sys.argv[1] == "api":
        # הרץ את ה-API server
        from stock_scanner.api import app
        import uvicorn
        port = int(os.getenv("PORT", 8000))
        uvicorn.run(app, host="0.0.0.0", port=port)
    else:
        # הקוד הרגיל שלך
        main()
```

---

## שלב 7: `railway.json`

```json
{
  "$schema": "https://railway.app/railway.schema.json",
  "build": {
    "builder": "NIXPACKS",
    "buildCommand": "pip install -r requirements.txt"
  },
  "deploy": {
    "startCommand": "python main.py api",
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 10
  }
}
```

---

## איך להריץ:

### 1. **אימון המודל (כרגיל):**
```bash
python train.py
```
זה יצור את הקבצים:
- `model.joblib`
- `model_ensemble.joblib`
- `scaler.joblib`

### 2. **הרצת ה-API:**
```bash
python main.py api
```
או:
```bash
uvicorn stock_scanner.api:app --reload
```

### 3. **בדיקה:**
```bash
curl http://localhost:8000/api/scanner/watchlist
```

---

## Deploy ל-Railway:

1. **העלה ל-GitHub:**
```bash
git add .
git commit -m "Added stock scanner API"
git push
```

2. **ב-Railway:**
   - New Project → Deploy from GitHub
   - הוסף משתני סביבה:
     ```
     SPREADSHEET_ID=your_sheet_id
     GCP_SA_JSON_PATH=/app/sa.json
     PORT=8000
     ```
   - העלה את `sa.json` כ-secret file

3. **Railway יריץ אוטומטית!** 🚀

---

## מה קיבלת?

✅ API מלא לסריקת מניות  
✅ משתמש במודל ה-Ensemble שלך  
✅ משולב עם Google Sheets שלך  
✅ יכול לעבוד לצד main.py הקיים  
✅ מוכן ל-Railway  

**רוצה שאבנה גם את הפרונטאנד React?** 🎨
